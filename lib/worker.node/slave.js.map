{"version":3,"sources":["worker.node/slave.js"],"names":[],"mappings":";;;;AAEA,IAAM,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC;;;;AAIzB,IAAI,mBAAmB,GAAG,KAAK,CAAC;AAChC,IAAI,cAAc,GAAG,0BAAW;AAC9B,SAAO,CAAC,KAAK,CAAC,8BAA8B,CAAC,CAAC;CAC/C,CAAC;;AAEF,SAAS,iBAAiB,GAAG;AAC3B,MAAI,mBAAmB,EAAE;AAAE,WAAO;GAAE;;AAEpC,SAAO,CAAC,EAAE,CAAC,mBAAmB,EAAE,UAAS,KAAK,EAAE;AAC9C,WAAO,CAAC,IAAI,CAAC;AACX,WAAK,EAAG,EAAE,OAAO,EAAG,KAAK,CAAC,OAAO,EAAE,KAAK,EAAG,KAAK,CAAC,KAAK,EAAE;KACzD,CAAC,CAAC;GACJ,CAAC,CAAC;;AAEH,qBAAmB,GAAG,IAAI,CAAC;CAC5B;;AAGD,SAAS,oBAAoB,CAAC,IAAI,EAAE;AAClC,MAAI,OAAO,GAAG;AACZ,UAAM,EAAN,MAAM;AACN,WAAO,EAAP,OAAO;AACP,iBAAa,EAAb,aAAa;AACb,gBAAY,EAAZ,YAAY;AACZ,UAAM,EAAU,EAAE,OAAO,EAAG,IAAI,EAAE;AAClC,WAAO,EAAP,OAAO;AACP,eAAW,EAAX,WAAW;AACX,cAAU,EAAV,UAAU;GACX,CAAC;;AAEF,IAAE,CAAC,eAAe,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AAClC,SAAO,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC;CAC/B;;AAGD,SAAS,kBAAkB,GAAU;oCAAN,IAAI;AAAJ,QAAI;;;;AAEjC,SAAO,CAAC,IAAI,CAAC,EAAC,QAAQ,EAAE,IAAI,EAAC,CAAC,CAAC;CAChC;;AAED,kBAAkB,CAAC,QAAQ,GAAG,YAAkB;qCAAN,IAAI;AAAJ,QAAI;;;;AAE5C,MAAI,IAAI,CAAC,CAAC,CAAC,CAAC,YAAY,MAAM,EAAE;;AAE9B,WAAO,CAAC,IAAI,CAAC,EAAC,QAAQ,EAAE,IAAI,EAAC,CAAC,CAAC;;GAEhC,MAAM;AACL,wBAAkB,kBAAI,IAAI,CAAC,CAAC;KAC7B;CACF,CAAC;;AAEF,SAAS,sBAAsB,CAAC,QAAQ,EAAE;AACxC,SAAO,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAR,QAAQ,EAAE,CAAC,CAAC;CAC5B;;;;;;;;;;;AAYD,OAAO,CAAC,EAAE,CAAC,SAAS,EAAE,UAAS,IAAI,EAAE;AACnC,MAAI,IAAI,CAAC,YAAY,EAAE;AACrB,kBAAc,GAAG,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;GACvC;;AAED,MAAI,IAAI,CAAC,YAAY,EAAE;AACrB,kBAAc,GAAG,oBAAoB,CAAC,mBAAmB,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC;GAC1E;;AAED,MAAI,IAAI,CAAC,KAAK,EAAE;;;AAGd,qBAAiB,EAAE,CAAC;;AAEpB,kBAAc,CAAC,IAAI,CAAC,KAAK,EAAE,kBAAkB,EAAE,sBAAsB,CAAC,CAAC;GACxE;CACF,CAAC,CAAC","file":"worker.node/slave.js","sourcesContent":["// not using ES6 import/export syntax, since we need to require() in a handler\n// what the ES6 syntax does not permit\nconst vm = require('vm');\n//const fs = require('fs');\n//const es = require('event-stream');\n\nlet errorCatcherInPlace = false;\nlet messageHandler = function() {\n  console.error('No thread logic initialized.');    // eslint-disable-line no-console\n};\n\nfunction setupErrorCatcher() {\n  if (errorCatcherInPlace) { return; }\n\n  process.on('uncaughtException', function(error) {\n    process.send({\n      error : { message : error.message, stack : error.stack }\n    });\n  });\n\n  errorCatcherInPlace = true;\n}\n\n\nfunction runAsSandboxedModule(code) {\n  var sandbox = {\n    Buffer,\n    console,\n    clearInterval,\n    clearTimeout,\n    module        : { exports : null },\n    require,\n    setInterval,\n    setTimeout\n  };\n\n  vm.runInNewContext(code, sandbox);\n  return sandbox.module.exports;\n}\n\n\nfunction messageHandlerDone(...args) {\n  //console.log('slave send!!!!');\n  process.send({response: args});\n}\n\nmessageHandlerDone.transfer = function(...args) {\n  //console.log('slave transfer!!!!');\n  if (args[-1] instanceof Buffer) {\n    //var buffer = args.pop();\n    process.send({response: args});\n    //pipe.write(buffer);\n  } else {\n    messageHandlerDone(...args);\n  }\n};\n\nfunction messageHandlerProgress(progress) {\n  process.send({ progress });\n}\n\n//let reader = fs.createReadStream('/dev/fd/4', {encoding: 'utf8'});\n\n\n/*\nlet p4 = process.stdio[4].pipe(es.split());\np4.on('data', (data) => {\n  console.log('stdio4: ' + data);\n});\n*/\n\nprocess.on('message', function(data) {\n  if (data.initByScript) {\n    messageHandler = require(data.script);\n  }\n\n  if (data.initByMethod) {\n    messageHandler = runAsSandboxedModule('module.exports = ' + data.method);\n  }\n\n  if (data.doRun) {\n    // it's a good idea to wait until first thread logic run to set this up,\n    // so initialization errors will be printed to console\n    setupErrorCatcher();\n\n    messageHandler(data.param, messageHandlerDone, messageHandlerProgress);\n  }\n});\n\n"],"sourceRoot":"/source/"}